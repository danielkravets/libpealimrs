// This file is @generated by prost-build.
/// Define message formats for your data structures
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WordForm {
    #[prost(enumeration = "Tense", tag = "1")]
    pub tense: i32,
    #[prost(enumeration = "Person", tag = "2")]
    pub person: i32,
    #[prost(enumeration = "Number", tag = "3")]
    pub number: i32,
    #[prost(enumeration = "Gender", tag = "4")]
    pub gender: i32,
    #[prost(string, tag = "5")]
    pub form: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub form_normalized: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub transcription: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub meaning: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "9")]
    pub form_vowelled: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WordData {
    #[prost(string, tag = "1")]
    pub url_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub word: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub word_en: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub word_ru: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub word_es: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub word_normalized: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub transcription: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub root: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub forms: ::prost::alloc::vec::Vec<WordForm>,
    #[prost(enumeration = "Binyan", tag = "10")]
    pub binyan: i32,
    #[prost(message, repeated, tag = "11")]
    pub passive: ::prost::alloc::vec::Vec<WordForm>,
    #[prost(enumeration = "Binyan", optional, tag = "12")]
    pub passive_binyan: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WordDataList {
    #[prost(message, repeated, tag = "1")]
    pub words: ::prost::alloc::vec::Vec<WordData>,
}
/// Define enums based on your Python Enum definitions
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Gender {
    M = 0,
    F = 1,
    AllG = 2,
}
impl Gender {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Gender::M => "M",
            Gender::F => "F",
            Gender::AllG => "ALL_G",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "M" => Some(Self::M),
            "F" => Some(Self::F),
            "ALL_G" => Some(Self::AllG),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Person {
    P1st = 0,
    P2nd = 1,
    P3rd = 2,
    AllP = 3,
}
impl Person {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Person::P1st => "P_1ST",
            Person::P2nd => "P_2ND",
            Person::P3rd => "P_3RD",
            Person::AllP => "ALL_P",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "P_1ST" => Some(Self::P1st),
            "P_2ND" => Some(Self::P2nd),
            "P_3RD" => Some(Self::P3rd),
            "ALL_P" => Some(Self::AllP),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Number {
    Singular = 0,
    Plural = 1,
}
impl Number {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Number::Singular => "SINGULAR",
            Number::Plural => "PLURAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SINGULAR" => Some(Self::Singular),
            "PLURAL" => Some(Self::Plural),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Tense {
    Past = 0,
    Present = 1,
    Future = 2,
    Imperative = 3,
}
impl Tense {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Tense::Past => "PAST",
            Tense::Present => "PRESENT",
            Tense::Future => "FUTURE",
            Tense::Imperative => "IMPERATIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAST" => Some(Self::Past),
            "PRESENT" => Some(Self::Present),
            "FUTURE" => Some(Self::Future),
            "IMPERATIVE" => Some(Self::Imperative),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Binyan {
    Paal = 0,
    Nifal = 1,
    Piel = 2,
    Pual = 3,
    Hifil = 4,
    Hufal = 5,
    Hitpael = 6,
}
impl Binyan {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Binyan::Paal => "PAAL",
            Binyan::Nifal => "NIFAL",
            Binyan::Piel => "PIEL",
            Binyan::Pual => "PUAL",
            Binyan::Hifil => "HIFIL",
            Binyan::Hufal => "HUFAL",
            Binyan::Hitpael => "HITPAEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAAL" => Some(Self::Paal),
            "NIFAL" => Some(Self::Nifal),
            "PIEL" => Some(Self::Piel),
            "PUAL" => Some(Self::Pual),
            "HIFIL" => Some(Self::Hifil),
            "HUFAL" => Some(Self::Hufal),
            "HITPAEL" => Some(Self::Hitpael),
            _ => None,
        }
    }
}
